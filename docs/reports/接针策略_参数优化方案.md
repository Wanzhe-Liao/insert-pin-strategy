# 三日暴跌接针策略 参数优化与回测方案（参考 XTrend）

本文将你的 Pine 脚本（“三日暴跌接针策略”）策略规则映射到 R/xts 数据，并参考 QCrypto 包的回测模式（与 XTrend 使用一致）设计一套可复用的参数优化脚本。结构包括：数据与时间框架、策略规则映射、回测与指标、参数空间与优化流程、并行与加速、示例代码与使用方法。

## 策略概述与数据准备
- 策略规则（简化说明）：
  - N 天内从过去最高价到当前最低价的跌幅达到 X%。满足则当日（或下一根）做多；
  - 固定止盈百分比 Y%、固定止损百分比 Z%。
- 数据来源：`cryptodata`（来自 `liaochu.RData`），每个元素为一个 `xts`（列为 `Open, High, Low, Close, Volume`），命名格式 `SYMBOL_TF`（如 `BTCUSDT_15m`、`ETHUSDT_1h`）。
- 时间框架：分时（5m/15m/30m/1h 等）。策略中的“天数”需要换算为“回看条数”：`lookbackBars = lookbackDays * (24*60 / tf_minutes)`。

## 规则映射到 R/xts
- 计算最近 N 天（不含当前 K 线）最高价：`highestHighPrev = runMax(High, lookbackBars) |> lag(1)`；
- 跌幅百分比：`percentDrop = (highestHighPrev - Low) / highestHighPrev * 100`；
- 入场条件：`cond_priceDrop = percentDrop >= minDropPercent`；
- 入场信号：仅在未持仓时触发一次（去重重复信号）；
- 出场信号：持仓期间若 `Close >= entryPrice*(1 + takeProfitPercent/100)` 或 `Close <= entryPrice*(1 - stopLossPercent/100)`，则平仓一次；
- 交易执行价格：通常选择“下一根开盘价”（更稳健），也可使用当前收盘价（与 Pine `process_orders_on_close` 近似）。脚本支持两种模式。

## 回测接口与评价指标（参考 XTrend/QCrypto）
- 回测接口：使用 QCrypto 的 `backtest(open, buy_signal, sell_signal, initial_capital, fee)`，其内部为 C++ 加速；
- 指标提取：
  - `Final_Capital`：`backtest` 输出中的资本曲线末值；
  - `Return_Percentage`：`backtest` 输出中的末值（策略收益率，%）；
  - `Trade_Count`：`sum(buy_signal)`；
  - `Max_Drawdown`：使用 `maxdrawdown_CPP(nav)` 计算资本曲线的最大回撤；
  - `Win_Rate`：`sum(returns>0)/sum(returns!=0)`；
  - `BH_Return`（买入持有）：`Close[end]/Close[start] - 1`；
  - `Excess_Return`：`Return_Percentage/100 - BH_Return`。

## 参数空间与优化目标
- 参数空间建议：
  - `lookbackDays`: `2:7`（天）；
  - `minDropPercent`: `seq(10, 40, by=5)`（%）；
  - `takeProfitPercent`: `c(5, 8, 10, 12, 15)`（%）；
  - `stopLossPercent`: `c(5, 8, 10, 12, 15)`（%）。
- 优化目标（可组合排序）：
  - 首要：`Return_Percentage` 最大；
  - 次要：`Max_Drawdown` 最小；
  - 辅助：`Trade_Count` 合理（过少/过多均不佳）、`Win_Rate` 较高、`Excess_Return` 为正。

## 并行与加速建议
- CPU 并行：使用 `pblapply` 或 `parLapply`，Windows 下建议集群并行而非 `mc`；
- GPU：本策略为规则驱动、无需 GPU 内核（XTrend 的 GPU 加速用于大规模参数 + C++ 内核场景）。如需大规模跨标的/跨分时优化，可按 CPU 并行分批执行。

## 关键实现（R 代码片段）
> 下列代码展示核心函数与单一标的优化流程；你可以放入脚本并按需修改参数空间与并行核数。

```r
suppressMessages({
  library(xts); library(data.table); library(pbapply); library(QCrypto)
})

# 从名称推断 TF 分钟数，例如 "BTCUSDT_15m" -> 15, "ETHUSDT_1h" -> 60
infer_tf_minutes <- function(name) {
  tf <- sub(".*_(.*)$", "\\1", name)
  if (grepl("m$", tf)) return(as.integer(sub("m$", "", tf)))
  if (grepl("h$", tf)) return(as.integer(sub("h$", "", tf)) * 60)
  if (grepl("d$", tf)) return(as.integer(sub("d$", "", tf)) * 24 * 60)
  stop("Unknown TF: ", tf)
}

# 构造 Pine 规则的买/卖信号（支持 next_bar_entry 模式）
build_signals <- function(dat, tf_minutes, lookbackDays, minDropPercent, takeProfitPercent, stopLossPercent, next_bar_entry = TRUE) {
  H <- dat$High; L <- dat$Low; O <- dat$Open; C <- dat$Close
  lookbackBars <- ceiling(lookbackDays * (24*60 / tf_minutes))
  hh <- zoo::rollapply(H, lookbackBars, max, align = "right", partial = FALSE)
  hh_prev <- lag(hh, 1)
  # 对齐长度
  min_len <- min(length(hh_prev), NROW(dat))
  hh_prev <- hh_prev[(length(hh_prev) - min_len + 1):length(hh_prev)]
  L <- L[(NROW(dat) - min_len + 1):NROW(dat)]
  O <- O[(NROW(dat) - min_len + 1):NROW(dat)]
  C <- C[(NROW(dat) - min_len + 1):NROW(dat)]

  percentDrop <- (hh_prev - L) / hh_prev * 100
  cond_priceDrop <- percentDrop >= minDropPercent

  n <- length(cond_priceDrop)
  buy_signal <- integer(n); sell_signal <- integer(n)
  in_trade <- FALSE; entry_price <- NA_real_

  for (i in seq_len(n)) {
    if (!in_trade && isTRUE(cond_priceDrop[i])) {
      in_trade <- TRUE
      # 选择入场价格基准：下一根开盘 或 当前收盘
      entry_price <- if (next_bar_entry && i < n) as.numeric(O[i+1]) else as.numeric(C[i])
      buy_signal[i] <- 1
    } else if (in_trade) {
      tp_price <- entry_price * (1 + takeProfitPercent/100)
      sl_price <- entry_price * (1 - stopLossPercent/100)
      price_chk <- as.numeric(C[i])
      if (!is.na(price_chk) && (price_chk >= tp_price || price_chk <= sl_price)) {
        sell_signal[i] <- 1
        in_trade <- FALSE; entry_price <- NA_real_
      }
    }
  }
  list(buy = buy_signal, sell = sell_signal, open = O)
}

# 单标的优化
optimize_drop_strategy <- function(dat, name, grid, init_equity = 100000, fee = 0.001, next_bar_entry = TRUE) {
  tf_minutes <- infer_tf_minutes(name)
  res_all <- list()
  pboptions(type = "timer")
  res <- pblapply(split(grid, seq(nrow(grid))), function(p) {
    sig <- build_signals(dat, tf_minutes,
                         lookbackDays = p$lookbackDays,
                         minDropPercent = p$minDropPercent,
                         takeProfitPercent = p$takeProfitPercent,
                         stopLossPercent = p$stopLossPercent,
                         next_bar_entry = next_bar_entry)
    bt <- backtest(sig$open, sig$buy, sig$sell, init_equity, fee)
    # 指标提取
    final_capital <- tail(bt$capital, 1)
    ret_pct <- tail(bt$return_percentage, 1)
    trade_cnt <- sum(sig$buy)
    # 最大回撤
    mdd <- as.numeric(QCrypto:::maxdrawdown_CPP(bt$capital))
    # 胜率
    win_rate <- sum(bt$returns > 0) / sum(bt$returns != 0)
    # 买入持有与超额
    bh <- as.numeric(tail(sig$open, 1) / head(sig$open, 1) - 1)
    excess <- ret_pct/100 - bh

    data.frame(
      symbol = name,
      lookbackDays = p$lookbackDays,
      minDropPercent = p$minDropPercent,
      takeProfitPercent = p$takeProfitPercent,
      stopLossPercent = p$stopLossPercent,
      Final_Capital = final_capital,
      Return_Percentage = ret_pct,
      Trade_Count = trade_cnt,
      Max_Drawdown = mdd,
      Win_Rate = win_rate,
      BH_Return = bh,
      Excess_Return = excess
    )
  })
  res_dt <- data.table::rbindlist(res)
  # 结果排序：收益优先、回撤次之
  res_dt[order(-Return_Percentage, Max_Drawdown)]
}

# 示例参数网格
param_grid <- expand.grid(
  lookbackDays = 2:7,
  minDropPercent = seq(10, 40, by = 5),
  takeProfitPercent = c(5, 8, 10, 12, 15),
  stopLossPercent = c(5, 8, 10, 12, 15)
)

# 使用示例：单标的
# load("c:/Users/ROG/Desktop/插针/liaochu.RData")
# dat <- cryptodata[["BTCUSDT_15m"]]
# res_btc_15m <- optimize_drop_strategy(dat, "BTCUSDT_15m", param_grid, init_equity = 100000, fee = 0.001, next_bar_entry = TRUE)
# head(res_btc_15m)

# 使用示例：批量（遍历 cryptodata 中所有标的与分时）
# all_results <- lapply(names(cryptodata), function(nm) {
#   optimize_drop_strategy(cryptodata[[nm]], nm, param_grid, init_equity = 100000, fee = 0.001, next_bar_entry = TRUE)
# })
# all_results_dt <- data.table::rbindlist(all_results)
# # 按 symbol 分组取最优参数
# best_by_symbol <- all_results_dt[, .SD[order(-Return_Percentage, Max_Drawdown)][1], by = symbol]
# best_by_symbol
```

## 使用步骤规划
1. 加载数据：`load("c:/Users/ROG/Desktop/插针/liaochu.RData")`，确认 `cryptodata` 列表与 OHLCV 列；
2. 设置参数网格：按需要调整 `lookbackDays/minDropPercent/takeProfitPercent/stopLossPercent`；
3. 选择执行模式：`next_bar_entry = TRUE`（更稳健）或 `FALSE`（收盘执行，与 Pine close 近似）；
4. 运行单标的优化：挑选如 `BTCUSDT_15m`；检查返回表并选取最优行；
5. 批量优化（可选）：遍历 `cryptodata` 全部元素，合并结果并按 `symbol` 选取最优；
6. 结果复核：关注收益率、回撤、交易次数、胜率与超额收益，避免过拟合；
7. 策略落地：将最优参数应用到 Pine 或 R 端进一步验证（样本外、走样本化回测等）。

## 注意事项与建议
- 时间框架换算：本方案将“天数”转换为“条数”；若在日线数据上运行，`tf_minutes=24*60`，换算仍成立；
- 信号去重：入场信号仅在未持仓时触发，避免重复开仓；
- 执行价选择：`next_bar_entry` 更接近真实撮合；若数据质量不齐（跳空等），可适当调整；
- 费用与滑点：`fee=0.001` 默认；如需考虑滑点可在执行价上加入偏移；
- 并行执行：Windows 环境建议用集群并行；大量参数与标的时请分批运行以控制内存；
- 风险控制：止盈止损为硬退出；可进一步加入仓位管理（如分批）与再入场冷却时间等增强鲁棒性；

以上方案将你的 Pine 规则忠实映射到 R/xts 并结合 QCrypto 的回测接口输出统一的优化结果，可直接在当前数据（`liaochu.RData`）上执行并筛选每个标的与分时的最优参数。